<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template name ="getClassName">
        <xsl:param name="name"></xsl:param>
        <xsl:variable name="first" select="substring-before($name, '.')"/>
        <xsl:variable name="second" select="substring-after($name, '.')"/>
        <xsl:value-of select="translate(substring($first, 1, 1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/><xsl:value-of select="substring($first, 2)"/>_<xsl:value-of select="translate(substring($second, 1, 1),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/><xsl:value-of select="substring($second, 2)"/>
    </xsl:template>
    <xsl:template name ="setParameter">
        <xsl:param name="sequence"></xsl:param>
        <xsl:param name="parameterName"></xsl:param>
        <xsl:variable name="type" select="substring($sequence, 1, 3)"/>
        <xsl:variable name="index" select="substring($sequence, 4)"/>
        <xsl:choose>
            <xsl:when test="$type = 'str' and $index &lt; '15'">result.strings[<xsl:value-of select="$index"/>] = getStringAfterKey(params, "<xsl:value-of select="$parameterName"/>=");
            </xsl:when>
            <xsl:when test="$type = 'int' and $index &lt; '10'">result.longs[<xsl:value-of select="$index"/>] = getLongAfterKey(params, "<xsl:value-of select="$parameterName"/>=");
            </xsl:when>
        </xsl:choose></xsl:template>
    <xsl:template name ="ParserBuilder">
        <xsl:param name="name"></xsl:param>
    public static class Parser$<xsl:call-template name="getClassName"><xsl:with-param name="name" select="$name"/></xsl:call-template> implements AccessToActionDetailUDTF.ApiMethodParser {
        public AccessToActionDetailUDTF.Result parse(String params) {
            AccessToActionDetailUDTF.Result result = new AccessToActionDetailUDTF.Result();
            <xsl:for-each select="./parameterInfoList/parameterInfo[injectOnly = 'false']"><xsl:call-template name="setParameter">
            <xsl:with-param name="sequence" select="sequence"/>
            <xsl:with-param name="parameterName" select="name"/></xsl:call-template></xsl:for-each>
            return result;
        }
    }
    </xsl:template>
    <xsl:template name ="MapBuilder">
        <xsl:param name="name"></xsl:param>
        parserMap.put("<xsl:value-of select="$name"/>", new Parser$<xsl:call-template name="getClassName"><xsl:with-param name="name" select="$name"/></xsl:call-template>());</xsl:template>
    <xsl:template match="/">// Auto Generated.  DO NOT EDIT!

package net.pocrd.etl.user.action;

import java.util.HashMap;

public class AutoGeneratedParser {
    public static HashMap<xsl:text disable-output-escaping="yes">&lt;</xsl:text>String, AccessToActionDetailUDTF.ApiMethodParser<xsl:text disable-output-escaping="yes">&gt;</xsl:text> parserMap = new HashMap<xsl:text disable-output-escaping="yes">&lt;</xsl:text>String, AccessToActionDetailUDTF.ApiMethodParser<xsl:text disable-output-escaping="yes">&gt;</xsl:text>();

    static {<xsl:for-each select="//Document/apiList/api"><xsl:call-template name="MapBuilder"><xsl:with-param name="name" select="methodName"/></xsl:call-template></xsl:for-each>
    }

    private static String getStringAfterKey(String source, String key) {
        int index1 = source.indexOf(key);
        if (index1 <xsl:text disable-output-escaping="yes">&lt;</xsl:text> 0) {
            return null;
        }
        int index2 = source.indexOf("<xsl:text disable-output-escaping="yes">&amp;</xsl:text>", index1);
        if (index2 <xsl:text disable-output-escaping="yes">&lt;</xsl:text> 0) {
            return source.substring(index1 + key.length());
        } else {
            return source.substring(index1 + key.length(), index2);
        }
    }

    private static Long getLongAfterKey(String source, String key) {
        try{
            int index1 = source.indexOf(key);
            String value = null;
            if (index1 <xsl:text disable-output-escaping="yes">&lt;</xsl:text> 0) {
                return null;
            }
            int index2 = source.indexOf("<xsl:text disable-output-escaping="yes">&amp;</xsl:text>", index1);
            if (index2 <xsl:text disable-output-escaping="yes">&lt;</xsl:text> 0) {
                value = source.substring(index1 + key.length());
            } else {
                value = source.substring(index1 + key.length(), index2);
            }
            return Long.parseLong(value);
        } catch (Exception e) {
            throw new RuntimeException("parse " + key + " failed. " + source, e);
        }
    }

    <xsl:for-each select="//Document/apiList/api"><xsl:call-template name="ParserBuilder"><xsl:with-param name="name" select="methodName"/></xsl:call-template></xsl:for-each>
}
    </xsl:template>
</xsl:stylesheet>
